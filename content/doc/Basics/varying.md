+++
title = "可变选项 Varying Choices"
date = 2021-03-20T15:09:55+08:00
weight = 16
chapter = false
pre = "<b>1.7 </b>"
+++

## 1.7.1 一次性选项

**Choices can only be used once**

通常情况下，游戏中的每个选项只能选一次。如果你的故事中没有循环，你很难注意到这个特性。但如果你用了循环，很快你会注意到选项消失了……

```
=== find_help === // 结点：需求帮助
你拼命地在人群中寻找一张友好的脸。
* 戴帽子的女人[？] 粗暴地把你推到一边。 -> find_help // 跳转到结点：需求帮助
* 拿公文包的男人[？] 很厌恶的从旁边匆匆而过。 -> find_help // 跳转到结点：需求帮助
```

```
你拼命地在人群中寻找一张友好的脸。
1: 戴帽子的女人？
2: 拿公文包的男人？

▶ 1
戴帽子的女人粗暴地把你推到一边。
你拼命地在人群中寻找一张友好的脸。
1: 拿公文包的男人？

▶
```

---

到下一个循环，你就没剩下选项了。 

## 1.7.2 后备选项 Fallback choices

上面的例子停下了，因为到选项时报错“没有内容了”（ out of content）。

```
▶ 1
拿公文包的男人很厌恶的从旁边匆匆而过。
你拼命地在人群中寻找一张友好的脸。

Runtime error in tests/test.ink line 6: ran out of content. Do you need a '-> DONE' or '-> END'?
```

我们可通过一个“后备选择”解决问题。后备选项不会直接展示给玩家，但当没有其他选项可选时，则会自动选择。

后备选项是一个简单的“没有文本的选项”：

```
* -> out_of_options
```

并在轻度滥用语法的情况下，我们可以让选项有文本内容，用“选项后加箭头”：

```
* -> 
  姆德一直无法解释他怎么从燃烧的车厢里出来的。 -> season_2
```

再看看之前的例子：

```
=== find_help === // 结点：需求帮助
你拼命地在人群中寻找一张友好的脸。
* 戴帽子的女人[？] 粗暴地把你推到一边。 -> find_help // 跳转到结点：需求帮助
* 拿公文包的男人[？] 很厌恶的从旁边匆匆而过。 -> find_help // 跳转到结点：需求帮助
  
 * ->  // ✨ 后备选项
    但一切都太迟了：你倒在站台上。一切都结束了。
    -> END // ✨ 故事线到此结束
```

```
你拼命地在人群中寻找一张友好的脸。
1: 戴帽子的女人？
2: 拿公文包的男人？

▶ 1
戴帽子的女人粗暴地把你推到一边。
你拼命地在人群中寻找一张友好的脸。
1: 拿公文包的男人？

▶ 1
拿公文包的男人很厌恶的从旁边匆匆而过。
你拼命地在人群中寻找一张友好的脸。
但一切都太迟了：你倒在站台上。一切都结束了。
```

---

## 1.7.3 固定选项 Sticky choices

当然，一次性有时不止我们想要的，因此我们有另一种选项：固定选项。固定选项用加号标记 `+` ，不会因选择而被用尽。

```
=== homers_couch === // 结点：霍默沙发
+ [再吃个甜甜圈] // ✨ 固定选项
  你又吃了一个甜甜圈。 -> homers_couch // 跳转到结点：霍默沙发
* [从沙发起身] 
  你挣扎着离开了沙发，去拯救世界。
    -> END
```
后备选项也可用固定选项。

```
=== conversation_loop // 结点：循环对话
* [聊天气] -> chat_weather 
* [聊孩子] -> chat_children 
+ -> sit_in_silence_again // ✨ 固定选项 & 固定选项
```
---

## 1.7.4 条件选项

你可以控制选项是否可选。ink 有很多逻辑可用，但最简单的是“玩家是否经历过特定内容”。

每个结点或针脚在游戏中都有唯一的地址（因此可以跳转到），并且我们可用相同的地址检测玩家是否经历过这块内容。

```
* { not visit_paris } [前往巴黎] -> visit_paris // 条件：没有经历过 参观巴黎结点
+ { visit_paris } [返回巴黎] -> visit_paris // 条件：经历过 参观巴黎结点
  
* { visit_paris.met_estelle } [打电话给埃斯特尔女士] -> phone_estelle // 条件：经历过 参观巴黎结点，见到埃斯特尔针脚
```

注意，一旦玩家经历过结点中的任何针脚，检测结点名称时都会是 true 。

还要注意，条件选项不会覆盖一次性选项，因此在需要重复时你依然需要固定选项。

### 进阶：多重条件

**Advanced: multiple conditions**

你也可以让一个选项有多个条件检测；如果这么做了，必须所有的检测都通过才会显示选项。

```
* { not visit_paris } [前往巴黎] -> visit_paris // 条件：没有经历过 参观巴黎结点
+ { visit_paris } { not bored_of_paris } [返回巴黎] -> visit_paris // 条件：经历过 参观巴黎结点；并且，没经历过 厌倦巴黎结点
```
### 逻辑运算符：AND OR

**Logical operators: AND and OR**

上面的“多重条件”实际上是条件用了编程的 AND 运算符。ink 通常支持 `and`（或写成 `&&`）以及 `or`（或写成 `||`），还有括号。

```
* { not (visit_paris or visit_rome) && (visit_london || visit_new_york) } [等等，去哪？我有些困惑。] -> visit_someplace
// { 非 （参观巴黎 或 参观罗马） 与 （参观伦敦 或 参观纽约）} ，即“不满足巴黎或罗马至少去过一个，并且伦敦或纽约至少去过一个”。
```

对于非编程人员而言，X `and` Y 必须都是 true 才会得到 true。X `or` Y 其中有一个 true 就是 true 了。我们不支持 `xor` 运算符。（注，xor 指“异或”，两个值不相同，结果为 true。两个值相同，结果为 false。）

你也可以用 `!` 表示 `not` 运算符，但考虑到可能与“一次性可变文本” `{!text}` 混淆，我们推荐使用 `not`。（注，not 运算如是 true 则得到 false，反之亦然。）

### 进阶：结点或针脚标签实际上有计数

**Advanced: knot/stitch labels are actually read counts**

```
* {seen_clue} [指控杰克逊先生] // 条件：经历过 看到线索结点
```
实际上，条件这里的检测并非 true 或 false，而是整数。结点或针脚有个整数变量，记录玩家经历这个地址的次数。

如果它不是 0 ，就会在上面得检测返回 true，但你也可更具体些：

```
* {seen_clue > 3} [指控杰克逊先生] // 条件：经历过3次以上 看到线索结点
```

### 进阶：更多逻辑

**Advanced: more logic**

Ink 支持的逻辑与条件要比这里多 —— 详见 “变量与逻辑”。


